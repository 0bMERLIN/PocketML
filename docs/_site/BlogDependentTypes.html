<!DOCTYPE html> <html lang="en-US"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <link rel="stylesheet" href="/assets/css/just-the-docs-default.css"> <link rel="stylesheet" href="/assets/css/just-the-docs-head-nav.css" id="jtd-head-nav-stylesheet"> <style id="jtd-nav-activation"> .site-nav > ul.nav-list:first-child > li:not(:nth-child(4)) > a, .site-nav > ul.nav-list:first-child > li > ul > li a { background-image: none; } .site-nav > ul.nav-list:not(:first-child) a, .site-nav li.external a { background-image: none; } .site-nav > ul.nav-list:first-child > li:nth-child(4) > a { font-weight: 600; text-decoration: none; }.site-nav > ul.nav-list:first-child > li:nth-child(4) > button svg { transform: rotate(-90deg); }.site-nav > ul.nav-list:first-child > li.nav-list-item:nth-child(4) > ul.nav-list { display: block; } </style> <script src="/assets/js/vendor/lunr.min.js"></script> <script src="/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <!-- Begin Jekyll SEO tag v2.8.0 --> <title>Blog: Dependent types with PocketML | PocketML</title> <meta name="generator" content="Jekyll v3.10.0" /> <meta property="og:title" content="Blog: Dependent types with PocketML" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="A functional language to kill boredom." /> <meta property="og:description" content="A functional language to kill boredom." /> <link rel="canonical" href="http://localhost:4000/BlogDependentTypes.html" /> <meta property="og:url" content="http://localhost:4000/BlogDependentTypes.html" /> <meta property="og:site_name" content="PocketML" /> <meta property="og:type" content="website" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="Blog: Dependent types with PocketML" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"WebPage","description":"A functional language to kill boredom.","headline":"Blog: Dependent types with PocketML","url":"http://localhost:4000/BlogDependentTypes.html"}</script> <!-- End Jekyll SEO tag --> </head> <body> <a class="skip-to-main" href="#main-content">Skip to main content</a> <svg xmlns="http://www.w3.org/2000/svg" class="d-none"> <symbol id="svg-link" viewBox="0 0 24 24"> <title>Link</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"> <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path> </svg> </symbol> <symbol id="svg-menu" viewBox="0 0 24 24"> <title>Menu</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"> <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line> </svg> </symbol> <symbol id="svg-arrow-right" viewBox="0 0 24 24"> <title>Expand</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"> <polyline points="9 18 15 12 9 6"></polyline> </svg> </symbol> <!-- Feather. MIT License: https://github.com/feathericons/feather/blob/master/LICENSE --> <symbol id="svg-external-link" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-external-link"> <title id="svg-external-link-title">(external link)</title> <path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line> </symbol> <symbol id="svg-doc" viewBox="0 0 24 24"> <title>Document</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file"> <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline> </svg> </symbol> <symbol id="svg-search" viewBox="0 0 24 24"> <title>Search</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"> <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line> </svg> </symbol> <!-- Bootstrap Icons. MIT License: https://github.com/twbs/icons/blob/main/LICENSE.md --> <symbol id="svg-copy" viewBox="0 0 16 16"> <title>Copy</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard" viewBox="0 0 16 16"> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1h1a1 1 0 0 1 1 1V14a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V3.5a1 1 0 0 1 1-1h1v-1z"/> <path d="M9.5 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3zm-3-1A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3z"/> </svg> </symbol> <symbol id="svg-copied" viewBox="0 0 16 16"> <title>Copied</title> <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-clipboard-check-fill" viewBox="0 0 16 16"> <path d="M6.5 0A1.5 1.5 0 0 0 5 1.5v1A1.5 1.5 0 0 0 6.5 4h3A1.5 1.5 0 0 0 11 2.5v-1A1.5 1.5 0 0 0 9.5 0h-3Zm3 1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5h-3a.5.5 0 0 1-.5-.5v-1a.5.5 0 0 1 .5-.5h3Z"/> <path d="M4 1.5H3a2 2 0 0 0-2 2V14a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V3.5a2 2 0 0 0-2-2h-1v1A2.5 2.5 0 0 1 9.5 5h-3A2.5 2.5 0 0 1 4 2.5v-1Zm6.854 7.354-3 3a.5.5 0 0 1-.708 0l-1.5-1.5a.5.5 0 0 1 .708-.708L7.5 10.793l2.646-2.647a.5.5 0 0 1 .708.708Z"/> </svg> </symbol> </svg> <div class="side-bar"> <div class="site-header" role="banner"> <a href="/" class="site-title lh-tight"> PocketML </a> <button id="menu-button" class="site-button btn-reset" aria-label="Toggle menu" aria-pressed="false"> <svg viewBox="0 0 24 24" class="icon" aria-hidden="true"><use xlink:href="#svg-menu"></use></svg> </button> </div> <nav aria-label="Main" id="site-nav" class="site-nav"> <ul class="nav-list"><li class="nav-list-item"><a href="/Guide.html" class="nav-list-link">Language (& Installation) Guide</a></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in Library Documentation category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/LibDocs.html" class="nav-list-link">Library Documentation</a><ul class="nav-list"><li class="nav-list-item"><a href="/LibDocs/calculus.html" class="nav-list-link">calculus</a></li><li class="nav-list-item"><a href="/LibDocs/dict.html" class="nav-list-link">dict</a></li><li class="nav-list-item"><a href="/LibDocs/either.html" class="nav-list-link">either</a></li><li class="nav-list-item"><a href="/LibDocs/graphing.html" class="nav-list-link">graphing</a></li><li class="nav-list-item"><a href="/LibDocs/image.html" class="nav-list-link">image</a></li><li class="nav-list-item"><a href="/LibDocs/input.html" class="nav-list-link">input</a></li><li class="nav-list-item"><a href="/LibDocs/list.html" class="nav-list-link">list</a></li><li class="nav-list-item"><a href="/LibDocs/math.html" class="nav-list-link">math</a></li><li class="nav-list-item"><a href="/LibDocs/maybe.html" class="nav-list-link">maybe</a></li><li class="nav-list-item"><a href="/LibDocs/numpy.html" class="nav-list-link">numpy</a></li><li class="nav-list-item"><a href="/LibDocs/parsing.html" class="nav-list-link">parsing</a></li><li class="nav-list-item"><a href="/LibDocs/shaders.html" class="nav-list-link">shaders</a></li><li class="nav-list-item"><a href="/LibDocs/sound.html" class="nav-list-link">sound</a></li><li class="nav-list-item"><a href="/LibDocs/std.html" class="nav-list-link">std</a></li><li class="nav-list-item"><a href="/LibDocs/string.html" class="nav-list-link">string</a></li><li class="nav-list-item"><a href="/LibDocs/tea.html" class="nav-list-link">tea</a></li><li class="nav-list-item"><a href="/LibDocs/ugraph.html" class="nav-list-link">ugraph</a></li><li class="nav-list-item"><a href="/LibDocs/util.html" class="nav-list-link">util</a></li></ul></li><li class="nav-list-item"><a href="/Hacking.html" class="nav-list-link">Hacking & Python Interop</a></li><li class="nav-list-item"><a href="/BlogDependentTypes.html" class="nav-list-link">Blog: Dependent types with PocketML</a></li><li class="nav-list-item"><a href="/BlogModules.html" class="nav-list-link">Blog: Module functors in PocketML</a></li><li class="nav-list-item"><a href="/Features.html" class="nav-list-link">Features &amp; The type system</a></li><li class="nav-list-item"><a href="/GameOfLife.html" class="nav-list-link">Walkthrough: Coding Game of Life in PocketML</a></li><li class="nav-list-item"><a href="/CalcGUI.html" class="nav-list-link">Walkthrough: Coding a GUI calculator in PocketML</a></li></ul> </nav> <footer class="site-footer"> This site uses <a href="https://github.com/just-the-docs/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll. </footer> </div> <div class="main" id="top"> <div id="main-header" class="main-header"> <div class="search" role="search"> <div class="search-input-wrap"> <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search PocketML" aria-label="Search PocketML" autocomplete="off"> <label for="search-input" class="search-label"><svg viewBox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label> </div> <div id="search-results" class="search-results"></div> </div> </div> <div class="main-content-wrap"> <div id="main-content" class="main-content"> <main> <h1 id="blog-dependent-types-with-pocketml"> <a href="#blog-dependent-types-with-pocketml" class="anchor-heading" aria-labelledby="blog-dependent-types-with-pocketml"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Blog: Dependent types with PocketML </h1> <p><small>Sep 4th ‘25</small></p><hr /> <p>As my language PocketML is becoming more and more usable, I wanted to combine my interest in dependent types with a suitable example I can implement in PocketML. This post highlights the core ideas of implementing a type checker for dependent types using λP, as I didn’t find any simple guides online.</p> <p>My goal for this post is for it to be understandable and usable for programming language devs and FP programmers that have worked with languages like Haskell, OCaml or Elm.</p> <p>At the end of this post you can also find a breakdown of how much time the PocketML compiler spends compiling the code, which is quite interesting, because I don’t think I’ve ever seen a compiler this slow!</p> <h4 id="10-λp"> <a href="#10-λp" class="anchor-heading" aria-labelledby="10-λp"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 1.0 λP </h4> <p>Different type systems in the family of the lambda calculus are labeled by their functionality. The <em>Simply Typed Lambda Calculus</em> (STLC) is the first step on our way to dependent typing and adds function types. Therefore, it’s also sometimes called “λ→”.</p> <blockquote> <p>Here’s an example:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>λ x : a . x
</code></pre></div> </div> <p>The above term has the type <code class="language-plaintext highlighter-rouge">a -&gt; a</code>.</p> <p>Or the equivalent in Haskell/OCaml/…:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>\x -&gt; x
</code></pre></div> </div> <p>You’ll probably have correctly identified this to be the identity function, that just returns its argument.</p> </blockquote> <p>Formally, the STLC includes <em>type variables</em> like <code class="language-plaintext highlighter-rouge">a</code> and function types like <code class="language-plaintext highlighter-rouge">a -&gt; a</code>.</p> <p>To get basic dependent types, we only have to add one more thing: The dependent function type Π (Pi). I like to see Pi as an extension on top of the regular <code class="language-plaintext highlighter-rouge">-&gt;</code>-type. The result is the language/type theory called λP. Let’s have a look at some use cases for Pi in a basic hypothetical dependently typed language.</p> <blockquote> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>head = λ (n : Nat) -&gt; λ (a : *) -&gt; λ (v : Vec (n+1) a) -&gt; case v
  | Cons x _ -&gt; x
</code></pre></div> </div> <p>”*” in this syntax just means “Type”; <code class="language-plaintext highlighter-rouge">a</code> is of type “*”, meaning it is a <em>type variable</em>.</p> <p>Notice the missing case for the empty Vec. We don’t need that because the type encodes that, for any natural number (here n = 0, 1, … ∞), the Vec has a length one larger. That makes the length of the Vec &gt;= 1 or non-empty.</p> <p>In the type of <code class="language-plaintext highlighter-rouge">head</code>, the <code class="language-plaintext highlighter-rouge">-&gt;</code> that would be used in the simply typed lambda calculus is now replaced with Pi-types:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>head : Π (n : Nat) -&gt; Π (a : *) -&gt; Π (v : Vec (n+a) a) -&gt; a
</code></pre></div> </div> <p>The return type <code class="language-plaintext highlighter-rouge">a</code> does not have any dependence on <code class="language-plaintext highlighter-rouge">v</code>, so we could also use the arrow type as a sort of syntax sugar for the non-dependent Pi:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>head : Π (n : Nat) -&gt; Π (a : *) -&gt; (Vec (n+a) a -&gt; a)
</code></pre></div> </div> </blockquote> <blockquote> <p>Here’s the identity function for all input types to further illustrate Pi:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>id : Π (t : *) -&gt; t -&gt; t
id = λ (t : *) -&gt; λ (x : t) -&gt; t
-- lets use id!
id Nat 10 -- returns 10, obviously.
</code></pre></div> </div> </blockquote> <p>Before we move on to the next section, I want to highlight the similarity between lambda functions and the Pi type. In the implementation, the only real difference is that we also assert type equality when applying a Pi. In the last example, we could have also used <code class="language-plaintext highlighter-rouge">id</code> like this:</p> <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">id</span> <span class="mi">10</span> <span class="kt">Nat</span>
</code></pre></div></div> <p>with the arguments in the wrong order. That’s where the type equality check should then yield a “Type mismatch” error, because the first Pi <code class="language-plaintext highlighter-rouge">Π (t : *) -&gt; ...</code> expects a type (again, represented syntactically as “*”), not a number like <code class="language-plaintext highlighter-rouge">10</code>.</p> <h4 id="11-grammar--the-ast"> <a href="#11-grammar--the-ast" class="anchor-heading" aria-labelledby="11-grammar--the-ast"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 1.1 Grammar &amp; the AST </h4> <p>As stated above, implementing dependent types is actually not that different from the simply typed lambda calculus, with the exception of adding Pi types.</p> <p>If you’ve written an interpreter for the STLC before, you probably know the drill; we start with our “expression” type, that holds our AST. From now on I’ll use PocketML, which is very similar to Haskell or OCaml.</p> <div class="language-haskell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">data</span> <span class="kt">Term</span>
    <span class="o">=</span> <span class="kt">Var</span> <span class="kt">String</span>
    <span class="o">|</span> <span class="kt">Lam</span> <span class="kt">String</span> <span class="kt">Term</span> <span class="kt">Term</span>
    <span class="o">|</span> <span class="kt">Pi</span> <span class="kt">String</span> <span class="kt">Term</span> <span class="kt">Term</span>
    <span class="o">|</span> <span class="kt">App</span> <span class="kt">Term</span> <span class="kt">Term</span>
    <span class="o">|</span> <span class="kt">Star</span>
    <span class="o">|</span> <span class="kt">Nat</span>
    <span class="o">|</span> <span class="kt">NatLit</span> <span class="kt">Number</span>
<span class="p">;</span>
</code></pre></div></div> <p>You should recognise <code class="language-plaintext highlighter-rouge">Var</code>, <code class="language-plaintext highlighter-rouge">Lam</code> (lambda function) and <code class="language-plaintext highlighter-rouge">App</code> (applying a function) from the simply typed lambda calculus. Types are also included in our Term type because dependent typing allows us to mix and match types and values! That explains <code class="language-plaintext highlighter-rouge">Nat</code>, which is the type of numbers (natural numbers). <code class="language-plaintext highlighter-rouge">NatLit</code> is such a number. <code class="language-plaintext highlighter-rouge">Star</code> is “*” from earlier (the type of types).</p> <h4 id="12-type-checking"> <a href="#12-type-checking" class="anchor-heading" aria-labelledby="12-type-checking"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 1.2 Type checking </h4> <p>Lets get straight to the type checker function, which is our end goal.</p> <p>Variables and numbers are pretty intuitive:</p> <div class="language-sml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">let</span> <span class="n">typ</span> <span class="p">:</span> <span class="n">Ctx</span> <span class="p">-&gt;</span> <span class="n">Term</span> <span class="p">-&gt;</span> <span class="n">Term</span><span class="p">;</span>
<span class="kr">let</span> <span class="n">typ</span> <span class="n">c</span> <span class="p">=</span> <span class="n">\</span><span class="kr">case</span>
      <span class="n">Var</span> <span class="n">x</span> <span class="p">-&gt;</span> <span class="p">(</span><span class="kr">case</span> <span class="n">dictGet</span> <span class="n">c</span> <span class="n">x</span>
        <span class="p">|</span> <span class="n">Just</span> <span class="n">res</span> <span class="p">-&gt;</span> <span class="n">res</span>
        <span class="p">|</span> <span class="n">Nothing</span> <span class="p">-&gt;</span> <span class="n">error</span> <span class="s2">"variable not found."</span><span class="p">)</span>
    <span class="p">|</span> <span class="n">Nat</span> <span class="p">-&gt;</span> <span class="n">Star</span>
    <span class="p">|</span> <span class="n">NatLit</span> <span class="p">_</span> <span class="p">-&gt;</span> <span class="n">Nat</span>
    <span class="p">|</span> <span class="p">...</span>
</code></pre></div></div> <p>Number literals (<code class="language-plaintext highlighter-rouge">NatLit</code>s) have the type <code class="language-plaintext highlighter-rouge">Nat</code> and <code class="language-plaintext highlighter-rouge">Nat</code> itself is a type, so it has type “*” (<code class="language-plaintext highlighter-rouge">Star</code>).</p> <p>Lambdas are surprisingly easy, their type is just a Pi type (our replacement for the boring old <code class="language-plaintext highlighter-rouge">-&gt;</code> type from the STLC) with the argument and the arguments type. The return type is just the type of the body.</p> <div class="language-sml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="p">...</span>
    <span class="p">|</span> <span class="n">Lam</span> <span class="n">x</span> <span class="n">t</span> <span class="n">b</span> <span class="p">-&gt;</span>
        <span class="kr">let</span> <span class="n">bodyType</span> <span class="p">=</span> <span class="n">typ</span> <span class="p">(</span><span class="n">dictInsert</span> <span class="n">x</span> <span class="n">c</span> <span class="n">t</span><span class="p">)</span> <span class="n">b</span><span class="p">;</span>
        <span class="n">Pi</span> <span class="n">x</span> <span class="n">t</span> <span class="n">bodyType</span>
    <span class="p">...</span>
</code></pre></div></div> <p>As their name suggests, Pi types are also just types, so their type is simply “*”.</p> <div class="language-sml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="p">...</span>
    <span class="p">|</span> <span class="n">Pi</span> <span class="n">x</span> <span class="n">t</span> <span class="n">b</span> <span class="p">-&gt;</span> <span class="n">Star</span>
    <span class="p">...</span>
</code></pre></div></div> <p>Lastly we need to handle application:</p> <div class="language-sml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">...</span>
<span class="p">|</span> <span class="n">App</span> <span class="n">f</span> <span class="n">a</span> <span class="p">-&gt;</span> <span class="p">(</span><span class="kr">case</span> <span class="n">typ</span> <span class="n">c</span> <span class="n">f</span>
    <span class="p">|</span> <span class="n">Pi</span> <span class="n">x</span> <span class="n">t</span> <span class="n">b</span> <span class="p">-&gt;</span>
        <span class="kr">let</span> <span class="n">aT</span> <span class="p">=</span> <span class="n">typ</span> <span class="n">c</span> <span class="n">a</span><span class="p">;</span>
        <span class="kr">let</span> <span class="p">_</span> <span class="p">=</span> <span class="kr">if</span> <span class="n">not</span> <span class="p">(</span><span class="n">betaEquiv</span> <span class="n">t</span> <span class="n">aT</span><span class="p">)</span>
            <span class="kr">then</span> <span class="n">error</span>
                <span class="p">(</span><span class="s2">"Type mismatch: "</span> <span class="n">+</span> <span class="n">str</span> <span class="n">t</span>
                <span class="n">+</span> <span class="s2">", "</span> <span class="n">+</span> <span class="n">str</span> <span class="n">aT</span><span class="p">)</span>
            <span class="kr">else</span> <span class="p">();</span>
        <span class="n">subst</span> <span class="n">x</span> <span class="n">a</span> <span class="n">b</span>
    <span class="p">|</span> <span class="n">o</span> <span class="p">-&gt;</span> <span class="n">error</span> <span class="p">(</span><span class="s2">"expected a Pi-type, got "</span> <span class="n">+</span> <span class="n">str</span> <span class="n">o</span><span class="p">))</span>
</code></pre></div></div> <p>First we get the type of the argument to match it againts what the Pi type expects.</p> <p>Let’s say we input a function to increment a <code class="language-plaintext highlighter-rouge">Nat</code> of the type <code class="language-plaintext highlighter-rouge">Π (n : Nat) -&gt; Nat</code> and the argument might have the type <code class="language-plaintext highlighter-rouge">*</code> because the programmer made a mistake.</p> <p>Next <code class="language-plaintext highlighter-rouge">betaEquiv</code> would determine that <code class="language-plaintext highlighter-rouge">Nat</code> != <code class="language-plaintext highlighter-rouge">Star</code> and we can throw a “Type mismatch” error!</p> <p>If we instead did get past the type match, we would substitute the parameter for the argument inside the return of the Pi-type.</p> <p>Let’s look at a more complicated case to see what the substitution <code class="language-plaintext highlighter-rouge">subst</code> does:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>head : Π (n : Nat) -&gt; Π (a : *) -&gt; Vec (n+1) a -&gt; a
head = ...

myVec : Vec 1 Nat
myVec = Cons 42 Nil

head 0 Nat myVec
</code></pre></div></div> <p>in the last line, we would initially apply <code class="language-plaintext highlighter-rouge">Π (n : Nat) -&gt; ...</code> to <code class="language-plaintext highlighter-rouge">0</code>. In the type checker case for <code class="language-plaintext highlighter-rouge">App</code>, one would the substitute (<code class="language-plaintext highlighter-rouge">subst</code>) <code class="language-plaintext highlighter-rouge">n</code> for <code class="language-plaintext highlighter-rouge">NatLit 0</code>.</p> <h4 id="13-are-we-done"> <a href="#13-are-we-done" class="anchor-heading" aria-labelledby="13-are-we-done"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 1.3 Are we done? </h4> <p>Sort of. We’re still missing an implementation for <code class="language-plaintext highlighter-rouge">betaEquiv</code> and <code class="language-plaintext highlighter-rouge">subst</code>. The following sections just cover the implementation of those, which might not be as interesting for people familiar with type checking (substitution) and beta equivalence.</p> <p>Beta equivalence is also incredibly cumbersome to implement in the AST representation we chose. DeBrujin indices, a different way of naming variables would make this a lot easier.</p> <p>Let’s get to it for the sake of completeness!</p> <h4 id="14-substitution"> <a href="#14-substitution" class="anchor-heading" aria-labelledby="14-substitution"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 1.4 Substitution </h4> <p>The substitution function just replaces any occurance of a given variable name with a given term.</p> <blockquote> <p><code class="language-plaintext highlighter-rouge">subst</code> is also the sort of substitution we intuitively do when plugging in a number into a mathematical function:</p> <p>If we let <code class="language-plaintext highlighter-rouge">f(x) = x + 10</code> then applying <code class="language-plaintext highlighter-rouge">f</code> means substituting <code class="language-plaintext highlighter-rouge">x</code> for our input:</p> <p><code class="language-plaintext highlighter-rouge">f(10) = 10 + 10 = 20</code></p> </blockquote> <div class="language-sml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">let</span> <span class="n">subst</span> <span class="p">:</span> <span class="n">String</span> <span class="p">-&gt;</span> <span class="n">Term</span> <span class="p">-&gt;</span> <span class="n">Term</span> <span class="p">-&gt;</span> <span class="n">Term</span><span class="p">;</span>
<span class="kr">let</span> <span class="n">subst</span> <span class="n">s</span> <span class="n">r</span> <span class="p">=</span> <span class="n">\</span><span class="kr">case</span>
    <span class="n">Var</span> <span class="n">x</span> <span class="p">-&gt;</span> <span class="kr">if</span> <span class="n">x</span> <span class="n">==</span> <span class="n">s</span> <span class="kr">then</span> <span class="n">r</span> <span class="kr">else</span> <span class="n">Var</span> <span class="n">x</span>
    <span class="p">|</span> <span class="n">App</span> <span class="n">f</span> <span class="n">a</span> <span class="p">-&gt;</span> <span class="n">App</span> <span class="p">(</span><span class="n">subst</span> <span class="n">s</span> <span class="n">r</span> <span class="n">f</span><span class="p">)</span> <span class="p">(</span><span class="n">subst</span> <span class="n">s</span> <span class="n">r</span> <span class="n">a</span><span class="p">)</span>
    <span class="p">|</span> <span class="n">Lam</span> <span class="n">x</span> <span class="n">t</span> <span class="n">b</span> <span class="p">-&gt;</span> <span class="n">Lam</span> <span class="n">x</span> <span class="p">(</span><span class="n">subst</span> <span class="n">s</span> <span class="n">r</span> <span class="n">t</span><span class="p">)</span> <span class="p">(</span><span class="n">subst</span> <span class="n">s</span> <span class="n">r</span> <span class="n">b</span><span class="p">)</span>
    <span class="p">|</span> <span class="n">Pi</span> <span class="n">x</span> <span class="n">t</span> <span class="n">b</span> <span class="p">-&gt;</span> <span class="n">Pi</span> <span class="n">x</span> <span class="p">(</span><span class="n">subst</span> <span class="n">s</span> <span class="n">r</span> <span class="n">t</span><span class="p">)</span> <span class="p">(</span><span class="n">subst</span> <span class="n">s</span> <span class="n">r</span> <span class="n">b</span><span class="p">)</span>
    <span class="p">|</span> <span class="n">other</span> <span class="p">-&gt;</span> <span class="n">other</span>
<span class="p">;</span>
</code></pre></div></div> <h4 id="15-beta-equivalence"> <a href="#15-beta-equivalence" class="anchor-heading" aria-labelledby="15-beta-equivalence"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 1.5 Beta equivalence </h4> <p>If you’ve used a language like haskell before, you know the usual type matching.</p> <p>Giving haskell the term <code class="language-plaintext highlighter-rouge">head [1,2]</code> will result in the type checker matching the list type in <code class="language-plaintext highlighter-rouge">head :: List a -&gt; a</code> with our input <code class="language-plaintext highlighter-rouge">List Int</code> for example. First we match <code class="language-plaintext highlighter-rouge">List</code> with <code class="language-plaintext highlighter-rouge">List</code> and then <code class="language-plaintext highlighter-rouge">a</code> with <code class="language-plaintext highlighter-rouge">Int</code>.</p> <p>Because dependent typing also allows for types like <code class="language-plaintext highlighter-rouge">Vec (10+1) Nat</code> (a vec of length 11), we need to “evaluate” the type before matching it. That’s the job of <code class="language-plaintext highlighter-rouge">betaEquiv</code>:</p> <div class="language-sml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">let</span> <span class="n">betaEquiv</span> <span class="p">:</span> <span class="n">Term</span> <span class="p">-&gt;</span> <span class="n">Term</span> <span class="p">-&gt;</span> <span class="n">Bool</span><span class="p">;</span>
<span class="kr">let</span> <span class="n">betaEquiv</span> <span class="n">t1</span> <span class="n">t2</span> <span class="p">=</span> <span class="n">alphaEquiv</span>
    <span class="n">dictEmpty</span> <span class="n">dictEmpty</span>
    <span class="p">(</span><span class="n">normalForm</span> <span class="n">t1</span><span class="p">)</span> <span class="p">(</span><span class="n">normalForm</span> <span class="n">t2</span><span class="p">);</span>
</code></pre></div></div> <p>Beta equivalence involves converting the types we’re comparing to a “normal form” (evaluating expressions like <code class="language-plaintext highlighter-rouge">10+1</code> etc.).</p> <h5 id="alpha-equivalence"> <a href="#alpha-equivalence" class="anchor-heading" aria-labelledby="alpha-equivalence"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Alpha equivalence </h5> <p>Then the resulting types are compared using alpha equivalence, which takes into account that types with different type variable names can have the same meaning: Take for example</p> <ul> <li><code class="language-plaintext highlighter-rouge">Π (t : *) -&gt; t -&gt; t</code></li> <li>vs. <code class="language-plaintext highlighter-rouge">Π (a : *) -&gt; a -&gt; a</code></li> </ul> <p>They’re both the type of the polymorphic identity function, just with different variable names. Alpha equivalence would still count them as equal, which is what we need.</p> <h4 id="16-alpha-equivalence"> <a href="#16-alpha-equivalence" class="anchor-heading" aria-labelledby="16-alpha-equivalence"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 1.6 Alpha equivalence </h4> <p>Here I will only cover the part of <code class="language-plaintext highlighter-rouge">alphaEquiv</code> that actually deals with the variable names. The rest just does a tree walk of the terms being compared and applies <code class="language-plaintext highlighter-rouge">alphaEquiv</code> to the sub-terms (just like <code class="language-plaintext highlighter-rouge">subst</code>). For more details, take a look at <a href="https://github.com/0bMERLIN/PocketML/blob/main/examples/examples/lp.ml">examples/examples/lp.ml</a> in the git repo.</p> <p>To check if two terms like <code class="language-plaintext highlighter-rouge">λ x : a . x</code> and <code class="language-plaintext highlighter-rouge">λ y : a . y</code> are alpha-equivalent, we will associate every variable with a number representing how far away from the last binder (lambda) it is. Our examples will now <em>both</em> become: <code class="language-plaintext highlighter-rouge">λ : a . 0</code>. “x” is now represented using “0”, because it is the variable bound at the 0th level of the term. In <code class="language-plaintext highlighter-rouge">alphaEquiv</code>, we keep track of the fact that “x” and “y” were bound in the 0th level of the term (the <code class="language-plaintext highlighter-rouge">Lam</code> node), using dictionaries. In this case, we would have <code class="language-plaintext highlighter-rouge">[("x", 0), ("y", 0)]</code>. If the variable is free, meaning it was not bound in the term we’re checking (like <code class="language-plaintext highlighter-rouge">a</code>), it will just be compared by its name.</p> <p>Also note, that we’re keeping track of the variables’ levels with <em>two</em> contexts/dictionaries, one for each of the terms.</p> <div class="language-sml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kr">let</span> <span class="n">alphaEquiv</span> <span class="p">:</span> <span class="n">Dict</span> <span class="n">Num</span> <span class="p">-&gt;</span> <span class="n">Dict</span> <span class="n">Num</span> <span class="p">-&gt;</span> <span class="n">Term</span> <span class="p">-&gt;</span> <span class="n">Term</span> <span class="p">-&gt;</span> <span class="n">Bool</span><span class="p">;</span>
<span class="kr">let</span> <span class="n">alphaEquiv</span> <span class="n">c1</span> <span class="n">c2</span> <span class="n">t1</span> <span class="n">t2</span> <span class="p">=</span> <span class="kr">case</span> <span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">)</span>
	<span class="p">|</span> <span class="p">(</span><span class="n">Var</span> <span class="n">x</span><span class="p">,</span> <span class="n">Var</span> <span class="n">y</span><span class="p">)</span> <span class="p">-&gt;</span>
		<span class="p">(</span><span class="kr">case</span> <span class="p">(</span><span class="n">dictGet</span> <span class="n">c1</span> <span class="n">x</span><span class="p">,</span> <span class="n">dictGet</span> <span class="n">c2</span> <span class="n">y</span><span class="p">)</span>
			<span class="p">|</span> <span class="p">(</span><span class="n">Just</span> <span class="n">v1</span><span class="p">,</span> <span class="n">Just</span> <span class="n">v2</span><span class="p">)</span> <span class="p">-&gt;</span>
				<span class="kr">let</span> <span class="p">_</span> <span class="p">=</span> <span class="n">print</span> <span class="p">(</span><span class="s2">"v1,v2: "</span> <span class="n">+</span> <span class="n">str</span> <span class="n">v1</span> <span class="n">+</span> <span class="s2">", "</span> <span class="n">+</span> <span class="n">str</span> <span class="n">v2</span><span class="p">);</span>
				<span class="n">v1</span> <span class="n">==</span> <span class="n">v2</span>
			<span class="p">|</span> <span class="p">(</span><span class="n">Nothing</span><span class="p">,</span> <span class="n">Nothing</span><span class="p">)</span> <span class="p">-&gt;</span>
				<span class="kr">let</span> <span class="p">_</span> <span class="p">=</span> <span class="n">print</span> <span class="p">(</span><span class="s2">"x,y: "</span> <span class="n">+</span> <span class="n">str</span> <span class="n">x</span> <span class="n">+</span> <span class="s2">", "</span> <span class="n">+</span> <span class="n">str</span> <span class="n">y</span><span class="p">);</span>
				<span class="n">x</span> <span class="n">==</span> <span class="n">y</span>
			<span class="p">|</span> <span class="p">_</span> <span class="p">-&gt;</span> <span class="n">False</span>
		<span class="p">)</span>
</code></pre></div></div> <p>When comparing two lambdas, we just save the names into the contexts and compare the sub-terms:</p> <div class="language-sml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">...</span>
<span class="p">|</span> <span class="p">(</span><span class="n">Lam</span> <span class="n">x1</span> <span class="n">t1</span> <span class="n">b1</span><span class="p">,</span> <span class="n">Lam</span> <span class="n">x2</span> <span class="n">t2</span> <span class="n">b2</span><span class="p">)</span> <span class="p">-&gt;</span>
    <span class="kr">let</span> <span class="n">l</span> <span class="p">=</span> <span class="n">len</span> <span class="p">(</span><span class="n">dictItems</span> <span class="n">c1</span><span class="p">);</span>
    <span class="n">alphaEquiv</span> <span class="n">c1</span> <span class="n">c2</span> <span class="n">t1</span> <span class="n">t2</span> <span class="n">&amp;&amp;</span> <span class="n">alphaEquiv</span>
        <span class="p">(</span><span class="n">dictInsert</span> <span class="n">x1</span> <span class="n">c1</span> <span class="n">l</span><span class="p">)</span>
        <span class="p">(</span><span class="n">dictInsert</span> <span class="n">x2</span> <span class="n">c2</span> <span class="n">l</span><span class="p">)</span>
        <span class="n">b1</span> <span class="n">b2</span>
<span class="p">...</span>
</code></pre></div></div> <h4 id="17-conclusion"> <a href="#17-conclusion" class="anchor-heading" aria-labelledby="17-conclusion"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> 1.7 Conclusion </h4> <p>As well as starting my journey into dependent typing, I also learned a lot about PocketML’s user experience:</p> <ul> <li>PocketML is a scripting language, meant for exactly these small-scale projects.</li> <li>Long compile times are the biggest issue I faced. <code class="language-plaintext highlighter-rouge">lp.ml</code> has 100 LoC and takes up to 30 seconds on the first compile! When library modules are cached, the time goes down to 10s, which is still horrible!</li> </ul> <p>Here’s a breakdown of the time usage when compiling <code class="language-plaintext highlighter-rouge">lp.ml</code>.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[PARSING] (examples/examples/lp.ml)	 2.4139

[PARSING] (examples/lib/dict.ml)	 0.3532
[TYPED] (examples/lib/dict.ml)	 0.0045

[PARSING] (examples/lib/maybe.ml)	 0.8008
[PARSING] (examples/lib/list.ml)	 3.8617
[PARSING] (examples/lib/util.ml)	 4.26
[TYPED] (examples/lib/util.ml)	 0.1461
[TYPED] (examples/lib/list.ml)	 5.4157

[CACHED] (examples/lib/util.ml)	 0

[PARSING] (examples/lib/string.ml)	 0.3469
[TYPED] (examples/lib/string.ml)	 0.002

[COMPILE] (examples/examples/lp.ml)	 13.5368
</code></pre></div></div> <p>For now I switched the parser to LALR, which yielded a 3x total compile time improvement (30s to 10s) from the Earley parser. As I’m working on an incredibly slow laptop, I’ll have to see how compile times hold up on my phone and if the user experience is acceptable now. You’ll hear from me again, if I do a rewrite!</p><hr /> <p>Thank you very much for reading until the end. This blog post was a lot of fun to write and I hope to find other topics I can cover in PocketML.</p> </main> </div> </div> <div class="search-overlay"></div> </div> </body> </html>
