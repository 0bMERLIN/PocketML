{"0": {
    "doc": "Language (& Installation) Guide",
    "title": "Language Guide",
    "content": "1.0 Installing . I recommend downloading the APK file from the bin/ directory in the github repo. The editor also works on linux. Clone the repo. Run main.py in python3.10 (or higher version) and install any libraries python complains about. Note: On first startup the app will some time to load, while the library and example files are downloaded from the github repo. The loading time depends on your internet connection. Put a file into Internal Storage/Android/data/org.test.myapp/files/ (over USB) if you want to stop the app from installing the default files. You can also build the project yourself using the buildozer tool. 1.1 Data Types . PocketML has records, tuples and string, number and boolean types. A word on the string syntax: As PocketML is a scripting/tinkering language for mobile devices, bulky syntax should be avoided. Strings can be delimited with ' or \" and can span multiple lines; there is no separate syntax for multiline strings. \"I am a string\" . \" I, too, am a string... and multiline! \" . ' // Maybe you're writing a fun little C interpreter in PocketML! // And want C source code strings in your PocketML code... printf(\"Here's some double quotes in a multiline string, very useful indeed...\"); ' . PocketML uses Sum types like most other statically typed functional languages: . data Maybe a | Just a | Nothing . You can also declare that a type exists, for example to represent a value from a function implemented in python (see “Hacking / Python interop” page). data PythonObject; . Type aliases can be used to abbreviate the names of other data types: . type Mb a = Maybe a; . 1.2 Branching . Pattern matching is based on the case keyword and can match basic data types: . case 1 | 1 -&gt; \"One\" | _ -&gt; \"Something else\" . And sum types (except for numpy arrays): . case Just 1 | Just x -&gt; print x | Nothing -&gt; () . Lists are also sum types: . case [1,2,3] | Cons x _ -&gt; print x | Nil -&gt; print \"empty...\" . PocketML also supports matching on records. Fields can be matched with a value (a), a name (b) or without a “=” / with their own name (c). case { a = 10, b = 42, c = 71 } | {a = 10, b = x, c} -&gt; print (x + c) . Tuples are supported aswell. case (1, 2, 3) | (a, b, c) -&gt; print (a + b + c) . Use if-then-else for branching: . let f x = if x then \"True!\" else \"false :(\"; f True . When programming with side effects, an else branch may not be needed. The if-then expression must always return Unit. let f : Bool -&gt; Unit; let f b = if b then print \"True!\"; ... 1.2.1 Patterned let &amp; lambda . The arguments of a let definition and lambdas (\\... -&gt; ...) can be patterns: . let unwrapM (Just x) = x; let unwrapE = \\(Right x) -&gt; x; . Another (less useful) example of patterned lets: . let f x 1 = x + 1; print $ f 2 1 . 1.3 Do-Syntax . When many functions need to be executed one after another, for example to cause side effects, the do-syntax can be used. let f _ = do print \"1\" print \"2\" print \"3\" launch_missiles () ; . Note: Do not confuse this do syntax with monadic do-notation in Haskell! This is more of a C-like block (e.g. { ...; ...; }). The do-syntax is not perfect and might fail to parse in some situations. When in doubt use let _ = a (); let _ = b (); ... 1.4 Lists . Lists can be created like in the following example: . import std; print [1, 2, 3] # =&gt; (Cons 1 (Cons 2 (Cons 3 Nil))) . Numpy arrays can be created using the @(x1, x2, x3, ...) syntax: . print (@(1, 2) + @(3, 4)) # =&gt; [4. 6.] . They have type Vec. 1.5 Tuples and Records . PocketML supports both tuples and records. It is best to use records and tuples sparingly, as custom data types carry more information and are more strongly typed. type Point = (Number, Number); type Person = { name: String , age: Number , location: Point }; . Records also support a sort of weak row-polymorphism. let getX : { x : a } -&gt; a; let getX r = r.x; print $ getX {x=10, y=20} . Generally a record {x : a, y : b} and a record {y : b} unify. That also means that the following example only fails at runtime. let getX : { x : a, y : b } -&gt; a; let getX r = r.x; print $ getX {y=20} . Note: The section Python Interop has an example of how this can be used to implement named default arguments. The standard library lib.std has functions for updating records: . import lib.std; let myrec = {x=1,y=2,z=3}; do print (with { x = 22 } myrec) print (recordMap (\\r -&gt; with {x=r.x+1} r) myrec) . 1.6 Functions, recursion and let . Variables are generally introduced using the let keyword. Let declarations can be used to introduce a variables type before defining it: . let pi : Number; let pi = 3; . Functions can be introduced using \\ and are anonymous. To create recursive functions, the rec keyword or an explicit type annotation is required: . let rec sum = \\x -&gt; case x | Nil -&gt; 0 | Cons x xs -&gt; add x (sum xs); print (sum [1,2,3,4]) . Or alternatively: . let sum : (List Number) -&gt; Number let sum = \\case | Nil -&gt; 0 | Cons x xs -&gt; add x (sum xs); print (sum [1,2,3,4]) . Note: The above example uses the \\case notation which is equivalent to \\x -&gt; case x .... Functions can also be introduced using let: . let greet x = print2 \"Hello,\" x; greet \"there!\" . 1.7 Modules . PocketML projects are organized into modules. A module exports variables, types and type aliases. The explicit module declaration can limit what is exported: . Note: Constructors must be exported explicitly . let greet x = print2 \"Hi,\" x; let pi = 4; data MyType = MyConstructor Number; module ( greet , pi , type MyType , MyConstructor ) . Modules can also use (*) to export all types and variables. let greet x = print2 \"Hi,\" x; let pi = 4; module (*) . Modules inside a directory can be addressed using .: . import directory.mymodule; . Note: Module imports are relative, but the lib/ folder is accessible from anywhere! From the syntax, you can see that importing modules from a higher-up directory (“../something.ml”) is not possible. Imports can also be selective (only importing some names from a module). Modules can also be aliased (given an explicit name). import lib.math (sin) as Math; import lib.calculus as Calc; import lib.std; print $ (Calc.diff sin 1) Math.pi . 1.8 Doc comments . The editor has a builtin search panel for looking up types or searching for a function with a certain type. Any comments before the semicolon in a declaration will be included as a doc comment: . data List a = Cons a (List a) | Nil # The default list type generated # by `[...]` ; let mkDict : a -&gt; Dict b # WARNING: `a` should always be a record. ; type Color = Vec # Just a vector... ; . Most of the standard library is written in a self-documenting way to save on excessive comment clutter when searching in the doc panel. If you want to hide a declaration from the search panel, you can include the --hide flag in the definition comment: . data List a # my own list :) # --hide ; . For library authors: The gen_lib_docs.py script generates markdown doc files from all .ml modules in the examples/lib/ directory. The module description can be defined using a ##-comment. Markdown can be inserted using ###: . ## My module. It provides T! ### ### Definitions data T = C Num; ### ### Functions let unT : T -&gt; Num; let unT = \\case C n -&gt; n; . For more information consult the “Docs” tab in the editor app that is available for android and linux. ",
    "url": "/Guide.html#language-guide",
    
    "relUrl": "/Guide.html#language-guide"
  },"1": {
    "doc": "Language (& Installation) Guide",
    "title": "Language (& Installation) Guide",
    "content": " ",
    "url": "/Guide.html",
    
    "relUrl": "/Guide.html"
  },"2": {
    "doc": "Hacking & Python Interop",
    "title": "Hacking / Extending",
    "content": "1.1 Writing your own libraries . PocketML is not opinionated when it comes to project structure. All default libraries are in lib/. You can also write bigger chunks of code on your pc for testing and then transfer them. Connect your phone via USB and open the folder Internal Storage/Android/data/org.test.myapp/files/. 1.2 Python interop . PocketML is compiled to python. It has access to all features of python and the libraries numpy, pygments, lark, and kivy. Python code can be included in PocketML code using %%% ... %%%. PocketML uses the PML_[varname] naming scheme internally. Python functions exported to PocketML should be named accordingly. %%% def half(x): return x / 2 PML_half = half %%%; let half : Number -&gt; Number; print (half 2) . Python code can also be used to compute values in PocketML code using the inline %% ... %% syntax. Python types are largely compatible with PocketML types. print %%f\"PocketML does not have f-strings but python does {'!'*10}\"%% . Another example: . import lib.std; # get name and greet! input \"Name:\" (\\nm -&gt; print %%f\"Hi, {PML_nm}!\"%%) . As discussed in the Language Guide on records, one can also build a function with default arguments using python interop: . let mkVec : { x : Number, y : Number, z : Number } -&gt; Vec; %%% def PML_mkVec(r): defaults = {\"x\":0,\"y\":0,\"z\":0} defaults.update(r) return np.array(list(defaults.values())) %%%; . print $ mkVec {y=20} # =&gt; [ 0 20 0] . 1.3 The editor . Extending and hacking! . The PocketML editor is accessible to the language by using python interop. The editor object can be accessed directly by the name editor. It contains the “terminalout” and “graphicalout” objects. %%% def cls(_): # example usage: # clear the terminal editor.terminalout.text = \"\" %%%; () . editor.graphicalout is the kivy object for the “Graphics” tab in the editor and can be added to / manipulated like any other kivy object. For a better insight into accessing the graphicalout object from code, refer to the tea.ml library. ",
    "url": "/Hacking.html#hacking--extending",
    
    "relUrl": "/Hacking.html#hacking--extending"
  },"3": {
    "doc": "Hacking & Python Interop",
    "title": "Hacking & Python Interop",
    "content": " ",
    "url": "/Hacking.html",
    
    "relUrl": "/Hacking.html"
  },"4": {
    "doc": "Library Documentation",
    "title": "Library Documentation",
    "content": "This is the documentation for the libraries available in PocketML. ",
    "url": "/LibDocs.html",
    
    "relUrl": "/LibDocs.html"
  },"5": {
    "doc": "Library Documentation",
    "title": "Libraries",
    "content": ". | math Advanced mathematical functions, functions on Numbers . | either Either type for errors etc. | tea Graphics framework inspired by TEA. Uses kivy and VDOM-diffing internally. Supports GUIs, canvas graphics &amp; shaders . | image A library for kivy textures. An Img is a kivy texture. Images can be loaded from disk or created programmatically. | shaders Internally used for working with kivy glsl shaders . | parsing A lark-based parser. Generated data compatible with a sum type of the form data Expr = CapitalizedRuleName ... | ... | maybe Maybe type with monad implementation . | numpy A library for using numpy in PocketML. | string Functions for working with the builtin String type. | sound Library for kivys sound system. | dict Dictionaries with String-keys. Internally python dicts. | graphing Plotting functions in 2D using the TEA framework. Generates a TEA-widget. | calculus Basic numeric calculus functions like differentiation, integration, series. | list A simple linked list implementation. | ugraph A simplistic Undirected graph. | std Imports lib.string, lib.maybe, lib.list, lib.util, lib.dict. Use for brevity. | util Util functions for the OS, kivy process, network and more. | input Simple binding for getting input from terminalout. | . ",
    "url": "/LibDocs.html#libraries",
    
    "relUrl": "/LibDocs.html#libraries"
  },"6": {
    "doc": "calculus",
    "title": "calculus.ml",
    "content": "Basic numeric calculus functions like differentiation, integration, series. ",
    "url": "/LibDocs/calculus.html#calculusml",
    
    "relUrl": "/LibDocs/calculus.html#calculusml"
  },"7": {
    "doc": "calculus",
    "title": "Definitions",
    "content": "Differentiation &amp; Integration . diff : (Number -&gt; Number) -&gt; Number -&gt; (Number -&gt; Number) . args: func, n returns: n-th derivative of func. integral : (Number -&gt; Number) -&gt; Number -&gt; Number -&gt; Number . args: func, x_start, x_end . Series expansions (Taylor, Fourier etc.) . taylor : (Number -&gt; Number) -&gt; Number -&gt; Number -&gt; (Number -&gt; Number) . args: f, n, x0, x . fourier : (Number -&gt; Number) -&gt; Number -&gt; (Number -&gt; Number) . args: f, m, x . ",
    "url": "/LibDocs/calculus.html#definitions",
    
    "relUrl": "/LibDocs/calculus.html#definitions"
  },"8": {
    "doc": "calculus",
    "title": "calculus",
    "content": " ",
    "url": "/LibDocs/calculus.html",
    
    "relUrl": "/LibDocs/calculus.html"
  },"9": {
    "doc": "dict",
    "title": "dict.ml",
    "content": "Dictionaries with String-keys. Internally python dicts. ",
    "url": "/LibDocs/dict.html#dictml",
    
    "relUrl": "/LibDocs/dict.html#dictml"
  },"10": {
    "doc": "dict",
    "title": "Definitions",
    "content": "Creation . data Dict a . mkDict : List (String, a) -&gt; Dict a . Accessing . dictItems : Dict a -&gt; List (String, a) . dictGet : Dict a -&gt; String -&gt; Maybe a . dictInsert : String -&gt; Dict a -&gt; a -&gt; Dict a . dictEmpty : Dict a . ",
    "url": "/LibDocs/dict.html#definitions",
    
    "relUrl": "/LibDocs/dict.html#definitions"
  },"11": {
    "doc": "dict",
    "title": "dict",
    "content": " ",
    "url": "/LibDocs/dict.html",
    
    "relUrl": "/LibDocs/dict.html"
  },"12": {
    "doc": "either",
    "title": "either.ml",
    "content": "Either type for errors etc. ",
    "url": "/LibDocs/either.html#eitherml",
    
    "relUrl": "/LibDocs/either.html#eitherml"
  },"13": {
    "doc": "either",
    "title": "Definitions",
    "content": "Definitions / Working with Either . data Either a b = Left a | Right b . unRight : Either a b -&gt; b . fromMaybe : b -&gt; Maybe a -&gt; Either b a . Monad definition . bind : Either e a -&gt; (a -&gt; Either e b) -&gt; Either e b . flatMap : (a -&gt; Either e b) -&gt; Either e a -&gt; Either e b . fmap : (a -&gt; b) -&gt; Either e a -&gt; Either e b . pure : a -&gt; Either e a . ",
    "url": "/LibDocs/either.html#definitions",
    
    "relUrl": "/LibDocs/either.html#definitions"
  },"14": {
    "doc": "either",
    "title": "either",
    "content": " ",
    "url": "/LibDocs/either.html",
    
    "relUrl": "/LibDocs/either.html"
  },"15": {
    "doc": "graphing",
    "title": "graphing.ml",
    "content": "Plotting functions in 2D using the TEA framework. Generates a TEA-widget. ",
    "url": "/LibDocs/graphing.html#graphingml",
    
    "relUrl": "/LibDocs/graphing.html#graphingml"
  },"16": {
    "doc": "graphing",
    "title": "Definitions",
    "content": "Functions . viewGraphs : List (Number-&gt;Number) -&gt; Number -&gt; Number -&gt; Number -&gt; Widget . ",
    "url": "/LibDocs/graphing.html#definitions",
    
    "relUrl": "/LibDocs/graphing.html#definitions"
  },"17": {
    "doc": "graphing",
    "title": "graphing",
    "content": " ",
    "url": "/LibDocs/graphing.html",
    
    "relUrl": "/LibDocs/graphing.html"
  },"18": {
    "doc": "image",
    "title": "image.ml",
    "content": "A library for kivy textures. An Img is a kivy texture. Images can be loaded from disk or created programmatically. ",
    "url": "/LibDocs/image.html#imageml",
    
    "relUrl": "/LibDocs/image.html#imageml"
  },"19": {
    "doc": "image",
    "title": "Definitions",
    "content": "Definitions &amp; Creating images/buffers . data Img . data Buffer . type Color = Vec . setpixel : Img -&gt; Vec -&gt; Color -&gt; Unit . image : Vec -&gt; Img . imgLoad : String -&gt; Img . imgBuf : Img -&gt; Buffer . Functions . imgSize : Img -&gt; Vec . imgHeight : Img -&gt; Number . imgWidth : Img -&gt; Number . imgCopy : Img -&gt; Img . imgMap : Img -&gt; (Number-&gt;Number-&gt;Color-&gt;Color) -&gt; Unit . imgGet : Buffer -&gt; Vec -&gt; Vec . imgSave : String -&gt; Img -&gt; Unit . imgClear : Img -&gt; Color -&gt; Unit . imgMapRect: Vec -&gt; Vec -&gt; Img -&gt; (Number-&gt;Number-&gt;Color-&gt;Color) -&gt; Unit . args: size, pos, img, func . imgSmooth : Img -&gt; Img . imgFlipH : Img -&gt; Img . imgFlipV : Img -&gt; Img . imgShade : Img -&gt; String -&gt; Img . data Atlas = Atlas Img (List Vec) . arguments: atlasTex, imgSizes . mkAtlasImg : List Img -&gt; Img . make an atlas of vertically stacked images from the input images. mkAtlas : List Img -&gt; Atlas . create an Atlas from the input images . ",
    "url": "/LibDocs/image.html#definitions",
    
    "relUrl": "/LibDocs/image.html#definitions"
  },"20": {
    "doc": "image",
    "title": "image",
    "content": " ",
    "url": "/LibDocs/image.html",
    
    "relUrl": "/LibDocs/image.html"
  },"21": {
    "doc": "input",
    "title": "input.ml",
    "content": "Simple binding for getting input from terminalout. ",
    "url": "/LibDocs/input.html#inputml",
    
    "relUrl": "/LibDocs/input.html#inputml"
  },"22": {
    "doc": "input",
    "title": "Definitions",
    "content": "input : String -&gt; (String -&gt; Unit) -&gt; Unit . ",
    "url": "/LibDocs/input.html#definitions",
    
    "relUrl": "/LibDocs/input.html#definitions"
  },"23": {
    "doc": "input",
    "title": "input",
    "content": " ",
    "url": "/LibDocs/input.html",
    
    "relUrl": "/LibDocs/input.html"
  },"24": {
    "doc": "list",
    "title": "list.ml",
    "content": "A simple linked list implementation. ",
    "url": "/LibDocs/list.html#listml",
    
    "relUrl": "/LibDocs/list.html#listml"
  },"25": {
    "doc": "list",
    "title": "Definitions",
    "content": "Types . data List a = Cons a (List a) | Nil . The default list type generated by [...] . Creating lists . range : Number -&gt; Number -&gt; List Number . srange : Number -&gt; Number -&gt; Number -&gt; List Number . start, end, step . Accessors . tail : List a -&gt; List a . tailSafe : List a -&gt; List a . head : List a -&gt; a . len : List a -&gt; Number . listAtSafe : Number -&gt; List a -&gt; Maybe a . listAt : Number -&gt; List a -&gt; a . take : Number -&gt; List a -&gt; List a . chunksOf : Number -&gt; List a -&gt; List (List a) . contains : a -&gt; List a -&gt; Bool . Sorting, etc. sort : List a -&gt; List a . nub : List a -&gt; List a . Manipulating lists . append : a -&gt; List a -&gt; List a . foldr : (b -&gt; a -&gt; b) -&gt; b -&gt; List a -&gt; b . extend : List a -&gt; List a -&gt; List a . concat : List (List a) -&gt; List a . filter : (a -&gt; Bool) -&gt; List a -&gt; List a . reverse : List a -&gt; List a . map : (a -&gt; b) -&gt; (List a) -&gt; List b . foreach2D : Number -&gt; Number -&gt; (Number-&gt;Number-&gt; Unit) -&gt; Unit . imap : (Number -&gt; a -&gt; b) -&gt; List a -&gt; List b . any : List Bool -&gt; Bool . zip : List a -&gt; List b -&gt; List (a,b) . ",
    "url": "/LibDocs/list.html#definitions",
    
    "relUrl": "/LibDocs/list.html#definitions"
  },"26": {
    "doc": "list",
    "title": "list",
    "content": " ",
    "url": "/LibDocs/list.html",
    
    "relUrl": "/LibDocs/list.html"
  },"27": {
    "doc": "math",
    "title": "math.ml",
    "content": "Advanced mathematical functions, functions on Numbers . ",
    "url": "/LibDocs/math.html#mathml",
    
    "relUrl": "/LibDocs/math.html#mathml"
  },"28": {
    "doc": "math",
    "title": "Definitions",
    "content": "Trig . sin : Number -&gt; Number . cos : Number -&gt; Number . tan : Number -&gt; Number . pi : Number . Misc. pow : Number -&gt; Number -&gt; Number . round : Number -&gt; Number -&gt; Number . ln : Number -&gt; Number . fac : Number -&gt; Number . exp : Number -&gt; Number . min : Number -&gt; Number -&gt; Number . max : Number -&gt; Number -&gt; Number . Predicates / Checking properties of numbers . mod : Number -&gt; Number -&gt; Number . divisible : Number -&gt; Number -&gt; Bool . odd : Number -&gt; Bool . even : Number -&gt; Bool . Random . noise : Vec -&gt; Number . ",
    "url": "/LibDocs/math.html#definitions",
    
    "relUrl": "/LibDocs/math.html#definitions"
  },"29": {
    "doc": "math",
    "title": "math",
    "content": " ",
    "url": "/LibDocs/math.html",
    
    "relUrl": "/LibDocs/math.html"
  },"30": {
    "doc": "maybe",
    "title": "maybe.ml",
    "content": "Maybe type with monad implementation . ",
    "url": "/LibDocs/maybe.html#maybeml",
    
    "relUrl": "/LibDocs/maybe.html#maybeml"
  },"31": {
    "doc": "maybe",
    "title": "Definitions",
    "content": "Type &amp; Creating / unwrapping . data Maybe a = Nothing | Just a . maybe : a -&gt; Maybe a -&gt; a . Monad implementation . flatMap : (a -&gt; Maybe b) -&gt; Maybe a -&gt; Maybe b . bind : Maybe a -&gt; (a -&gt; Maybe b) -&gt; Maybe b . pure : a -&gt; Maybe a . fmap : (a -&gt; b) -&gt; Maybe a -&gt; Maybe b . mapM : (a -&gt; Maybe b) -&gt; List a -&gt; Maybe (List b) . ",
    "url": "/LibDocs/maybe.html#definitions",
    
    "relUrl": "/LibDocs/maybe.html#definitions"
  },"32": {
    "doc": "maybe",
    "title": "maybe",
    "content": " ",
    "url": "/LibDocs/maybe.html",
    
    "relUrl": "/LibDocs/maybe.html"
  },"33": {
    "doc": "numpy",
    "title": "numpy.ml",
    "content": "A library for using numpy in PocketML. ",
    "url": "/LibDocs/numpy.html#numpyml",
    
    "relUrl": "/LibDocs/numpy.html#numpyml"
  },"34": {
    "doc": "numpy",
    "title": "Definitions",
    "content": "Type Aliases . type Size = List Number . type Index = List Number . Creating arrays . array : List Number -&gt; Vec . zeros : Size -&gt; Vec . full : Size -&gt; Number -&gt; Vec . linspace : Number -&gt; Number -&gt; Number -&gt; Vec . start, end, nsteps . Getters . toList : Vec -&gt; List Number . only 1-dim.! . size : Vec -&gt; Size . &lt;=&gt; arr.shape in numpy! . get : Index -&gt; Vec -&gt; Number . slice : Index -&gt; Index -&gt; Vec -&gt; Vec . | start, end, input_array | fails if out of bounds | . sliceInc : Index -&gt; Index -&gt; Vec -&gt; Vec . like slice but end index is included. slicePartial : Index -&gt; Index -&gt; Vec -&gt; Vec . same as slice, but return all elements in index range instead of failing . Manipulating Vecs . set : Index -&gt; Number -&gt; Vec -&gt; Vec . vectorize : (Number -&gt; Number) -&gt; Vec -&gt; Vec . ivectorize : (Index -&gt; Number -&gt; Number) -&gt; Vec -&gt; Vec . sum : Vec -&gt; Number . dot : Vec -&gt; Vec -&gt; Number . flatten : Vec -&gt; Vec . delete : Number -&gt; Vec -&gt; Vec . args: i, arr remove the element at i only for flat Vecs . concatenate : Number -&gt; Vec -&gt; Vec -&gt; Vec . args: axis, arr1, arr2 . reshape : Size -&gt; Vec -&gt; Vec . transpose : Vec -&gt; Vec . ",
    "url": "/LibDocs/numpy.html#definitions",
    
    "relUrl": "/LibDocs/numpy.html#definitions"
  },"35": {
    "doc": "numpy",
    "title": "numpy",
    "content": " ",
    "url": "/LibDocs/numpy.html",
    
    "relUrl": "/LibDocs/numpy.html"
  },"36": {
    "doc": "parsing",
    "title": "parsing.ml",
    "content": "A lark-based parser. Generated data compatible with a sum type of the form data Expr = CapitalizedRuleName ... | ... ",
    "url": "/LibDocs/parsing.html#parsingml",
    
    "relUrl": "/LibDocs/parsing.html#parsingml"
  },"37": {
    "doc": "parsing",
    "title": "Definitions",
    "content": "Types . type GrammarError = String . type ParseError = String . Creating parsers . parser : String -&gt; Either GrammarError ( String -&gt; Either ParseError a ) . args: grammar, string . ",
    "url": "/LibDocs/parsing.html#definitions",
    
    "relUrl": "/LibDocs/parsing.html#definitions"
  },"38": {
    "doc": "parsing",
    "title": "parsing",
    "content": " ",
    "url": "/LibDocs/parsing.html",
    
    "relUrl": "/LibDocs/parsing.html"
  },"39": {
    "doc": "shaders",
    "title": "shaders.ml",
    "content": "Internally used for working with kivy glsl shaders . ",
    "url": "/LibDocs/shaders.html#shadersml",
    
    "relUrl": "/LibDocs/shaders.html#shadersml"
  },"40": {
    "doc": "shaders",
    "title": "Definitions",
    "content": " ",
    "url": "/LibDocs/shaders.html#definitions",
    
    "relUrl": "/LibDocs/shaders.html#definitions"
  },"41": {
    "doc": "shaders",
    "title": "shaders",
    "content": " ",
    "url": "/LibDocs/shaders.html",
    
    "relUrl": "/LibDocs/shaders.html"
  },"42": {
    "doc": "sound",
    "title": "sound.ml",
    "content": "Library for kivys sound system. ",
    "url": "/LibDocs/sound.html#soundml",
    
    "relUrl": "/LibDocs/sound.html#soundml"
  },"43": {
    "doc": "sound",
    "title": "Definitions",
    "content": "Types . data Sound . Generating Sounds . max_amp : Number . sound : (Number -&gt; Number) -&gt; Number -&gt; Sound . beep : Number -&gt; Number -&gt; Sound . Playback . play : Sound -&gt; Unit . example: play $ beep 440 1 . ",
    "url": "/LibDocs/sound.html#definitions",
    
    "relUrl": "/LibDocs/sound.html#definitions"
  },"44": {
    "doc": "sound",
    "title": "sound",
    "content": " ",
    "url": "/LibDocs/sound.html",
    
    "relUrl": "/LibDocs/sound.html"
  },"45": {
    "doc": "std",
    "title": "std.ml",
    "content": "Imports lib.string, lib.maybe, lib.list, lib.util, lib.dict. Use for brevity. ",
    "url": "/LibDocs/std.html#stdml",
    
    "relUrl": "/LibDocs/std.html#stdml"
  },"46": {
    "doc": "std",
    "title": "Definitions",
    "content": " ",
    "url": "/LibDocs/std.html#definitions",
    
    "relUrl": "/LibDocs/std.html#definitions"
  },"47": {
    "doc": "std",
    "title": "std",
    "content": " ",
    "url": "/LibDocs/std.html",
    
    "relUrl": "/LibDocs/std.html"
  },"48": {
    "doc": "string",
    "title": "string.ml",
    "content": "Functions for working with the builtin String type. ",
    "url": "/LibDocs/string.html#stringml",
    
    "relUrl": "/LibDocs/string.html#stringml"
  },"49": {
    "doc": "string",
    "title": "Definitions",
    "content": "str : a -&gt; String . split : String -&gt; String -&gt; List String . replace : String -&gt; String -&gt; String -&gt; String . isNumeric : String -&gt; Bool . strIn : String -&gt; String -&gt; Bool . strLen : String -&gt; Number . strHead : String -&gt; String . strTail : String-&gt; String . ",
    "url": "/LibDocs/string.html#definitions",
    
    "relUrl": "/LibDocs/string.html#definitions"
  },"50": {
    "doc": "string",
    "title": "string",
    "content": " ",
    "url": "/LibDocs/string.html",
    
    "relUrl": "/LibDocs/string.html"
  },"51": {
    "doc": "tea",
    "title": "tea.ml",
    "content": "Graphics framework inspired by TEA. Uses kivy and VDOM-diffing internally. Supports GUIs, canvas graphics &amp; shaders . ",
    "url": "/LibDocs/tea.html#teaml",
    
    "relUrl": "/LibDocs/tea.html#teaml"
  },"52": {
    "doc": "tea",
    "title": "Definitions",
    "content": "Types . type Color = Vec . Alias used for clarity. Vec of length 4. data Uniform = UniformFloat String Number | UniformInt String Number | UniformVec2 String Vec | UniformVec3 String Vec | UniformVec4 String Vec | UniformTex0 String Img . Uniform types for shaders. Arguments: uniformName, value . data Widget = Rect Color Vec Vec | TRect Img Vec Vec | SRect String (List Uniform) Vec Vec | Btn String String Vec Vec | Slider String Number Number Number Number Vec Vec | Label String String Vec Vec | Line (List Vec) Number Color | Many (List Widget) | ColorPicker String Vec Vec . | Attributes for Widgets |   | . | Rect | color, size, pos | . | TRect | texture, size, pos | . | Btn | name, text, size, pos | . | Slider | name, min, max, step, value, size, pos | . | Label | name, text, size, pos | . | Line | polygon-points, width, color | . | Many | children | . data Event = Tick | BtnPressed String | BtnReleased String | BtnHeld String | SliderMoved String Number | ColorPicked String Color . Event type for the tick function in the app. Make sure pattern matching on events is exhaustive, so tick does not throw an error. Starting the App . app : state -&gt; (Event -&gt; state -&gt; state) -&gt; (state -&gt; Widget) -&gt; Unit . starts an app given an initial state, tick and view . forceUpdate : state -&gt; state . The view gets updated based on the state. The app assumes that view is pure: It always returns the same Widgets for the same state. When side effects do need to be used for some reason, the tick function can request an update. Example: . let view _ = Label \"time\" (str $ time ()) @(200, 200) @(0, 0); let tick _ _ = forceUpdate (); # Note that the state is Unit and constant. setTick () tick view . stop : Unit -&gt; Unit . Effectful. Stops the app. Takes effect on the next tick, the current tick is stil executed. Example: . let tick event state = do if state &gt; 1000 then stop () inc state; let view state = Label \"mylabel\" (str state) @(200, 200) @(0, 0); setTick 0 . Basic kinds of apps / patterns . staticView : (Unit -&gt; Widget) -&gt; Unit . Renders a view and then halts the app. Use for graphing, etc. Getters . width : Number . height: Number . getFPS : Unit -&gt; Number . Positioning / layouts . setPos : Widget -&gt; Vec -&gt; Unit . randPos : Unit -&gt; Vec . grid : Vec -&gt; Vec -&gt; Num -&gt; Num -&gt; List (Vec -&gt; Widget) -&gt; Widget . Colors &amp; constants . red : Color . black : Color . white : Color . blue : Color . green : Color . yellow : Color . ",
    "url": "/LibDocs/tea.html#definitions",
    
    "relUrl": "/LibDocs/tea.html#definitions"
  },"53": {
    "doc": "tea",
    "title": "tea",
    "content": " ",
    "url": "/LibDocs/tea.html",
    
    "relUrl": "/LibDocs/tea.html"
  },"54": {
    "doc": "ugraph",
    "title": "ugraph.ml",
    "content": "A simplistic Undirected graph. ",
    "url": "/LibDocs/ugraph.html#ugraphml",
    
    "relUrl": "/LibDocs/ugraph.html#ugraphml"
  },"55": {
    "doc": "ugraph",
    "title": "Definitions",
    "content": "Types . type Edges a = Dict (List a) . type Vertices a = List a . data Graph a = Graph (Edges a) (Vertices a) . Functions . edgesFromGraph : Graph a -&gt; List (List a) . ",
    "url": "/LibDocs/ugraph.html#definitions",
    
    "relUrl": "/LibDocs/ugraph.html#definitions"
  },"56": {
    "doc": "ugraph",
    "title": "ugraph",
    "content": " ",
    "url": "/LibDocs/ugraph.html",
    
    "relUrl": "/LibDocs/ugraph.html"
  },"57": {
    "doc": "util",
    "title": "util.ml",
    "content": "Util functions for the OS, kivy process, network and more. ",
    "url": "/LibDocs/util.html#utilml",
    
    "relUrl": "/LibDocs/util.html#utilml"
  },"58": {
    "doc": "util",
    "title": "Definitions",
    "content": "Time . time : Unit -&gt; Number . traceTime : (Unit -&gt; b) -&gt; b . log the time an action takes to execute . setInterval : Number -&gt; state -&gt; (state-&gt;state) -&gt; Unit . args: n, state, tick run tick every n seconds. setUpdate : state -&gt; (state-&gt;state) -&gt;Unit . Terminal . cls : Unit -&gt; Unit . error : String -&gt; a . setTermFontSize : Number -&gt; Unit . str : a -&gt; String . deprecated. Use lib.string (str) . printl : List a -&gt; Unit . Misc. setreclimit : Number -&gt; Unit . setCompilerCWD : String -&gt; Unit . randint : Number -&gt; Number -&gt; Number . File system . fileexists : String -&gt; Bool . readFile : String -&gt; Maybe String . readFileUnsafe : String -&gt; String . Network . download : String -&gt; String -&gt; Unit . Basic functions . copy : a -&gt; a . uncurry2 : (a -&gt; b -&gt; c) -&gt; (a,b) -&gt; c . not : Bool -&gt; Bool . float : a -&gt; Number . int : a -&gt; Number . neg : Number -&gt; Number . between : Number-&gt; Number -&gt; Number -&gt; Bool . id : a -&gt; a . const : a -&gt; b -&gt; a . when : Bool -&gt; (Unit -&gt; Unit) -&gt; Unit . mapRecord : (a -&gt; a) -&gt; a -&gt; a . with : a -&gt; b -&gt; b . union : a -&gt; a -&gt; a . times : Number -&gt; (a -&gt; a) -&gt; a -&gt; a . ftee : (a -&gt; Unit) -&gt; (a -&gt; a) -&gt; a -&gt; a . ",
    "url": "/LibDocs/util.html#definitions",
    
    "relUrl": "/LibDocs/util.html#definitions"
  },"59": {
    "doc": "util",
    "title": "util",
    "content": " ",
    "url": "/LibDocs/util.html",
    
    "relUrl": "/LibDocs/util.html"
  },"60": {
    "doc": "Blog: Dependent types with PocketML",
    "title": "Blog: Dependent types with PocketML",
    "content": "# Blog: Dependent types with PocketML Sep 4th '25 --- As my language PocketML is becoming more and more usable, I wanted to combine my interest in dependent types with a suitable example I can implement in PocketML. This post highlights the core ideas of implementing a type checker for dependent types using λP, as I didn't find any simple guides online. My goal for this post is for it to be understandable and usable for programming language devs and FP programmers that have worked with languages like Haskell, OCaml or Elm. At the end of this post you can also find a breakdown of how much time the PocketML compiler spends compiling the code, which is quite interesting, because I don't think I've ever seen a compiler this slow! #### 1.0 λP Different type systems in the family of the lambda calculus are labeled by their functionality. The _Simply Typed Lambda Calculus_ (STLC) is the first step on our way to dependent typing and adds function types. Therefore, it's also sometimes called \"λ→\". > Here's an example: > ``` > λ x : a . x > ``` > The above term has the type `a -> a`. > > Or the equivalent in Haskell/OCaml/...: > ``` > \\x -> x > ``` > You'll probably have correctly identified this to be the identity function, that just returns its argument. Formally, the STLC includes _type variables_ like `a` and function types like `a -> a`. To get basic dependent types, we only have to add one more thing: The dependent function type Π (Pi). I like to see Pi as an extension on top of the regular `->`-type. The result is the language/type theory called λP. Let's have a look at some use cases for Pi in a basic hypothetical dependently typed language. >``` >head = λ (n : Nat) -> λ (a : *) -> λ (v : Vec (n+1) a) -> case v > | Cons x _ -> x >``` > \"\\*\" in this syntax just means \"Type\"; `a` is of type \"*\", meaning it is a _type variable_. > > Notice the missing case for the empty Vec. > We don't need that because the type encodes that, for any natural number (here n = 0, 1, ... ∞), the Vec has a length one larger. That makes the length of the Vec >= 1 or non-empty. > > In the type of `head`, the `->` that would be used in the simply typed lambda calculus is now replaced with Pi-types: > ``` > head : Π (n : Nat) -> Π (a : *) -> Π (v : Vec (n+a) a) -> a > ``` > The return type `a` does not have any dependence on `v`, so we could also use the arrow type as a sort of syntax sugar for the non-dependent Pi: > ``` > head : Π (n : Nat) -> Π (a : *) -> (Vec (n+a) a -> a) > ``` >Here's the identity function for all input types to further illustrate Pi: >``` >id : Π (t : *) -> t -> t >id = λ (t : *) -> λ (x : t) -> t >-- lets use id! >id Nat 10 -- returns 10, obviously. >``` Before we move on to the next section, I want to highlight the similarity between lambda functions and the Pi type. In the implementation, the only real difference is that we also assert type equality when applying a Pi. In the last example, we could have also used `id` like this: ```haskell id 10 Nat ``` with the arguments in the wrong order. That's where the type equality check should then yield a \"Type mismatch\" error, because the first Pi `Π (t : *) -> ...` expects a type (again, represented syntactically as \"\\*\"), not a number like `10`. #### 1.1 Grammar & the AST As stated above, implementing dependent types is actually not that different from the simply typed lambda calculus, with the exception of adding Pi types. If you've written an interpreter for the STLC before, you probably know the drill; we start with our \"expression\" type, that holds our AST. From now on I'll use PocketML, which is very similar to Haskell or OCaml. ```haskell data Term = Var String | Lam String Term Term | Pi String Term Term | App Term Term | Star | Nat | NatLit Number ; ``` You should recognise `Var`, `Lam` (lambda function) and `App` (applying a function) from the simply typed lambda calculus. Types are also included in our Term type because dependent typing allows us to mix and match types and values! That explains `Nat`, which is the type of numbers (natural numbers). `NatLit` is such a number. `Star` is \"\\*\" from earlier (the type of types). #### 1.2 Type checking Lets get straight to the type checker function, which is our end goal. Variables and numbers are pretty intuitive: ```sml let typ : Ctx -> Term -> Term; let typ c = \\case Var x -> (case dictGet c x | Just res -> res | Nothing -> error \"variable not found.\") | Nat -> Star | NatLit _ -> Nat | ... ``` Number literals (`NatLit`s) have the type `Nat` and `Nat` itself is a type, so it has type \"\\*\" (`Star`). Lambdas are surprisingly easy, their type is just a Pi type (our replacement for the boring old `->` type from the STLC) with the argument and the arguments type. The return type is just the type of the body. ```sml ... | Lam x t b -> let bodyType = typ (dictInsert x c t) b; Pi x t bodyType ... ``` As their name suggests, Pi types are also just types, so their type is simply \"\\*\". ```sml ... | Pi x t b -> Star ... ``` Lastly we need to handle application: ```sml ... | App f a -> (case typ c f | Pi x t b -> let aT = typ c a; let _ = if not (betaEquiv t aT) then error (\"Type mismatch: \" + str t + \", \" + str aT) else (); subst x a b | o -> error (\"expected a Pi-type, got \" + str o)) ``` First we get the type of the argument to match it againts what the Pi type expects. Let's say we input a function to increment a `Nat` of the type `Π (n : Nat) -> Nat` and the argument might have the type `*` because the programmer made a mistake. Next `betaEquiv` would determine that `Nat` != `Star` and we can throw a \"Type mismatch\" error! If we instead did get past the type match, we would substitute the parameter for the argument inside the return of the Pi-type. Let's look at a more complicated case to see what the substitution `subst` does: ``` head : Π (n : Nat) -> Π (a : *) -> Vec (n+1) a -> a head = ... myVec : Vec 1 Nat myVec = Cons 42 Nil head 0 Nat myVec ``` in the last line, we would initially apply `Π (n : Nat) -> ...` to `0`. In the type checker case for `App`, one would the substitute (`subst`) `n` for `NatLit 0`. #### 1.3 Are we done? Sort of. We're still missing an implementation for `betaEquiv` and `subst`. The following sections just cover the implementation of those, which might not be as interesting for people familiar with type checking (substitution) and beta equivalence. Beta equivalence is also incredibly cumbersome to implement in the AST representation we chose. DeBrujin indices, a different way of naming variables would make this a lot easier. Let's get to it for the sake of completeness! #### 1.4 Substitution The substitution function just replaces any occurance of a given variable name with a given term. > `subst` is also the sort of substitution we intuitively do when plugging in a number into a mathematical function: > >If we let `f(x) = x + 10` >then applying `f` means substituting `x` for our input: > > `f(10) = 10 + 10 = 20` ```sml let subst : String -> Term -> Term -> Term; let subst s r = \\case Var x -> if x == s then r else Var x | App f a -> App (subst s r f) (subst s r a) | Lam x t b -> Lam x (subst s r t) (subst s r b) | Pi x t b -> Pi x (subst s r t) (subst s r b) | other -> other ; ``` #### 1.5 Beta equivalence If you've used a language like haskell before, you know the usual type matching. Giving haskell the term `head [1,2]` will result in the type checker matching the list type in `head :: List a -> a` with our input `List Int` for example. First we match `List` with `List` and then `a` with `Int`. Because dependent typing also allows for types like `Vec (10+1) Nat` (a vec of length 11), we need to \"evaluate\" the type before matching it. That's the job of `betaEquiv`: ```sml let betaEquiv : Term -> Term -> Bool; let betaEquiv t1 t2 = alphaEquiv dictEmpty dictEmpty (normalForm t1) (normalForm t2); ``` Beta equivalence involves converting the types we're comparing to a \"normal form\" (evaluating expressions like `10+1` etc.). ##### Alpha equivalence Then the resulting types are compared using alpha equivalence, which takes into account that types with different type variable names can have the same meaning: Take for example - `Π (t : *) -> t -> t` - vs. `Π (a : *) -> a -> a` They're both the type of the polymorphic identity function, just with different variable names. Alpha equivalence would still count them as equal, which is what we need. #### 1.6 Alpha equivalence Here I will only cover the part of `alphaEquiv` that actually deals with the variable names. The rest just does a tree walk of the terms being compared and applies `alphaEquiv` to the sub-terms (just like `subst`). For more details, take a look at [examples/examples/lp.ml](https://github.com/0bMERLIN/PocketML/blob/main/examples/examples/lp.ml) in the git repo. To check if two terms like `λ x : a . x` and `λ y : a . y` are alpha-equivalent, we will associate every variable with a number representing how far away from the last binder (lambda) it is. Our examples will now _both_ become: `λ : a . 0`. \"x\" is now represented using \"0\", because it is the variable bound at the 0th level of the term. In `alphaEquiv`, we keep track of the fact that \"x\" and \"y\" were bound in the 0th level of the term (the `Lam` node), using dictionaries. In this case, we would have `[(\"x\", 0), (\"y\", 0)]`. If the variable is free, meaning it was not bound in the term we're checking (like `a`), it will just be compared by its name. Also note, that we're keeping track of the variables' levels with _two_ contexts/dictionaries, one for each of the terms. ```sml let alphaEquiv : Dict Num -> Dict Num -> Term -> Term -> Bool; let alphaEquiv c1 c2 t1 t2 = case (t1, t2) | (Var x, Var y) -> (case (dictGet c1 x, dictGet c2 y) | (Just v1, Just v2) -> let _ = print (\"v1,v2: \" + str v1 + \", \" + str v2); v1 == v2 | (Nothing, Nothing) -> let _ = print (\"x,y: \" + str x + \", \" + str y); x == y | _ -> False ) ``` When comparing two lambdas, we just save the names into the contexts and compare the sub-terms: ```sml ... | (Lam x1 t1 b1, Lam x2 t2 b2) -> let l = len (dictItems c1); alphaEquiv c1 c2 t1 t2 && alphaEquiv (dictInsert x1 c1 l) (dictInsert x2 c2 l) b1 b2 ... ``` #### 1.7 Conclusion As well as starting my journey into dependent typing, I also learned a lot about PocketML's user experience: - PocketML is a scripting language, meant for exactly these small-scale projects. - Long compile times are the biggest issue I faced. `lp.ml` has 100 LoC and takes up to 30 seconds on the first compile! When library modules are cached, the time goes down to 10s, which is still horrible! Here's a breakdown of the time usage when compiling `lp.ml`. ``` [PARSING] (examples/examples/lp.ml) 2.4139 [PARSING] (examples/lib/dict.ml) 0.3532 [TYPED] (examples/lib/dict.ml) 0.0045 [PARSING] (examples/lib/maybe.ml) 0.8008 [PARSING] (examples/lib/list.ml) 3.8617 [PARSING] (examples/lib/util.ml) 4.26 [TYPED] (examples/lib/util.ml) 0.1461 [TYPED] (examples/lib/list.ml) 5.4157 [CACHED] (examples/lib/util.ml) 0 [PARSING] (examples/lib/string.ml) 0.3469 [TYPED] (examples/lib/string.ml) 0.002 [COMPILE] (examples/examples/lp.ml) 13.5368 ``` For now I switched the parser to LALR, which yielded a 3x total compile time improvement (30s to 10s) from the Earley parser. As I'm working on an incredibly slow laptop, I'll have to see how compile times hold up on my phone and if the user experience is acceptable now. You'll hear from me again, if I do a rewrite! --- Thank you very much for reading until the end. This blog post was a lot of fun to write and I hope to find other topics I can cover in PocketML. ",
    "url": "/BlogDependentTypes.html",
    
    "relUrl": "/BlogDependentTypes.html"
  },"61": {
    "doc": "Blog: Module functors in PocketML",
    "title": "Blog: Module functors in PocketML",
    "content": "# Blog: Module functors in PocketML July 12th '25 --- I recently posted about PocketML on reddit and got a comment about the lack of modules in a language with \"ML\" in the name. TL;DR for this post: - modules are good :) - PocketML can do modules using records (see code below) - No modules in the standard library though, because they take too long to compile and are not terse on the users side. #### 1.0 Modules in StandardML The core idea is to be able to reuse more of the (library) code we write, by replacing type-specific functions with a module that our code takes as a parameter and which can be switched out by the user/caller depending on what type they want our code to process. More on this in section 1.1. Here's a quick rundown of how StandardML does this: - *signatures* are the type signatures of modules. They specify the contents of the module. - *modules* are the containers for the code/types we want to pass around. - *functors* are (potentially compile-time) functions that take a module and return a module. An example could be a `Dictionary` functor that takes in a module describing a hashable type and returns a module with all the important dictionary functions for this type. #### 1.1 End goal Let's take the example of getting the second (\"snd\") element from a sequence: ```python # gets the second element from a Vec let vecSnd : Vec -> Number; let vecSnd = ...; let listSnd : List a -> a; let listSnd = ...; let strSnd : String -> String; let ... ``` We'd have to write the same function for every type! This pattern actually comes up in PocketML's standard library: There's `strLen`, `len` (for lists) and `vecLen`. That's atrocious from an ML programmers point of view! Imagine adding another type - then we'd have to write every operation again. The most important use case for ML modules is now to turn the first code fragment (which scales badly) into the following one: ``` let snd : (module Sequence l e) -> l -> e; let snd m seq = m.getElementAt 0 seq; ``` We can just write one generic function that works on every type that has a corresponding `Sequence` module implemented for it. In our example `String`, `List` and `Vec` all support indexing, so implementing `Sequence` is trivial. #### 1.2 Actually implementing it As noted at the start, we do have a way to store named values/functions and pass them around - records. Passing around types is actually just as easy, but only if we do some reparameterisation (`List a` would become `Seq (List a) a` in module form): ```python data Seq l e = Seq { hd : l -> e , tl : l -> l } # a sequence with a head and tail. ; ``` This is an example of how one would create a module _signature_ in PocketML. Let's implement this module for `Vec`s: ```sml type VecSeq = Seq Vec Number; let vecTail : Vec -> Vec; let vecTail v = vecSlice 1 (vecLen v) v; let vecSeq : VecSeq; let vecSeq = Seq { hd = vecAt 0, tl = vecTail }; ``` That was easy and we need stuff like head and tail for vectors anyways! (I'd count this as zero overhead/unnescessary code for now!) Now another user might want to take the second element of a list. Hopefully, instead of writing a list-specific `snd` function, they do the following: ```python data Snd l e = Snd { snd : l -> e } # something `l` you can take the second # element `e` of ; let snd : Snd l e -> l -> e # getter for ease of use ; let snd m = case m | Snd s -> s.snd; let functorSnd : Seq l e -> Snd l e; let functorSnd m = case m | Seq s -> Snd { snd = times 2 (s.tl) >> s.hd }; ``` They might just pass in their implementation of `Seq` for lists, but we want to operate on vectors now. We can just reuse their code by passing in our `Vec` sequence! ```sml let vecSnd : Snd Vec Number; let vecSnd = functorSnd vecSeq; ``` If we leave out the type annotation, that's just one line per type. We've gone from writing every general function for every type (Imagine writing `map`, `filter`, `foldr`, `indexAt` etc. for all types that store multiple elements) to writing _a single line_ for every type. Thats O(N^2) to O(N) lines of code, which is quite amazing actually. With 10 sequence-like types and 20 generic functions, we'd have to write at least 200 lines if every function was a one liner. Now we only have to write 30 lines. #### 1.3 Overhead for the user Using our \"snd\" function for `Vec`s looks like this: ``` (snd vecSnd) @(1,2,3,4); ``` That's actually longer than with our naïve implementation, but the idea is that the time we waste using modules is completely offset by the time we saved earlier. Modern ML languages often use implicit modules to reduce boilerplate for the user. #### 1.4 Modules in the standard library One issue is that compiling modules needs a lot of type checking. Because PocketML is mainly a mobile app, we can't waste too much time compiling libraries. Using the naïve implementation, we just have to read in all the type declarations, because the functionality is usually implemented using python interop. One thing I will consider using this design pattern for, is to get rid of all the horrible variants of `len`. They introduce a lot of mental overhead which is not welcome in a language meant for tinkering. --- Thank you very much for reading 'til the end. I might write some more blog posts if I come across another interesting concept I can bring into PocketML. ### Correction / Update After more research & discussion, this seems to be more of a dictionary-passing implementation of type-classes + module functors. PocketML might get opaque types in the future to harness the power of modular abstraction. Better (qualified/selective) imports have now been added to the language to allow for cleaner namespaces. ",
    "url": "/BlogModules.html",
    
    "relUrl": "/BlogModules.html"
  },"62": {
    "doc": "Walkthrough: Coding a GUI calculator in PocketML",
    "title": "Walkthrough: Coding a GUI calculator in PocketML",
    "content": "## Walkthrough: Coding a GUI calculator in PocketML This walkthrough shows the core functionality of `lib.tea`. #### 1.1 TEA-architecture The Elm Architecture (TEA) is a GUI architecture that decouples the app logic (`tick`), visuals/GUI (`view`) and initial state (`init`). The essential data types for TEA in PocketML are: | | - | - | `Widget` | GUI components like buttons, text or simple shapes/sprites |`Event`|When a button is pressed or a frame is rendered, the `update` function receives an event.| #### 1.2 Evaluating expressions Our calculator will have to calculate an expression from a string. PocketML does include an example with an expression evaluator, but in this case we'll use python interop: ```python %%% def PML_eval(s): try: return str(round(eval(s),4)) except ZeroDivisionError: return \"error: division by zero\" %%%; let eval : String -> String; ``` #### 1.3 State / Logic Our calculator will have buttons and a text display that shows the current expression. When the \"=\" button is pressed, the text display will show the result of the calculation. So our state will just be a String. ```sml type State = String; let init = \"\"; ``` To update our state we will use a tick function, that react to the button events. When \"C\" (clear) is pressed, the state will become the empty string. When \"=\" is pressed, the result of the expression is written into the state. When another button is pressed and that button happens to be a valid calculator button, the button text will be added to the state. > Note: We also have to include a default case! lib.tea automatically skips rerendering frames when the state didn't change. The core assumption is that the `view` function is pure. Updates can be forced by using `forceUpdate state` in the default case of `tick`. ```sml let tick : Event -> State -> State; let tick e s = case e | BtnPressed \"=\" -> eval (replace \"^\" \"**\" s) | BtnPressed \"C\" -> \"\" | BtnPressed x -> if isNumeric x || strIn x \"()+-*/^.\" then s+x else s | _ -> s; ``` #### 1.4 Making the UI layout Our view includes buttons and the state text. Buttons accept a text _and_ a name, similar to `id` in html. It is used for UI-diffing in the backend and also the argument of `BtnPressed` in our `tick` function. > Note: We could write make all the buttons manually. Instead we will write a 1D list of button labels and then place / create the buttons based on the index in the list. ```sml let mkBtn w n t = let pos = @(n-4*int (n/4), 4-int (n/4)) ° w; Btn t t pos @(w*.9,w*.9); ``` Our button layout is: ```sml let btnLayout = [ \"C\", \"(\", \")\", \"/\", \"7\", \"8\", \"9\", \"*\", \"4\", \"5\", \"6\", \"-\", \"1\", \"2\", \"3\", \"+\", \".\", \"0\", \"=\", \"^\" ]; ``` #### 1.5 View Putting it all together we can generate a view that includes both the buttons and a label with the current expression text: > Note: The Many widget is similar to a html div. It allows us to return multiple widgets from the view. They can also be nested. ```sml let view : State -> Widget; let view s = let w = width/5; let btns = Many (imap (mkBtn w) btnLayout); let inp = Label s \"inp\" @(0,w*5) @(w*4,w); Many [inp, btns]; ``` #### 1.6 Running the app `lib.tea` apps can be launched as follows: ```sml setTick init tick view ``` #### 1.7 Gallery / Results ![](/calculator.png) > Note: This screenshot is from linux, on android the layout or font might change a little depending on your kivy installation / android version. Kivy labels don't have background by default. As an exercise you could add a `Rect pos size color` behind the label inside `view`! ",
    "url": "/CalcGUI.html",
    
    "relUrl": "/CalcGUI.html"
  },"63": {
    "doc": "Features &amp; The type system",
    "title": "Features &amp; The type system",
    "content": "## Features & The type system #### 1.1 Syntax PocketML`s syntax is largely based on Standard-ML and Haskell. Some quirks include: - Separation of top-level statements using `;` ```sml let a = 10; let b = 20; print (a + b) ``` - Comments using `#` ```python # i am a comment ``` ##### GUI A large part of PocketML is its editor. Use the `Editor` tab in the top toolbar to edit files. Close files by long pressing the file tab. Results show up in either the `Graphics` tab for graphics or the `Text Out` tab for text output. The info box above the keyboard shows the type of the symbol the cursor is on when clicked (no live type checking yet, because the typechecker is too slow). Manage project files and directories in the `Files` tab. For advanced file management use a File manager app that can access the `InternalStorage/Android/data/org.myapp.test/files/` directory. The `Docs` tab provides a Hoogle-like interface for searching types, names or libraries. #### 1.2 Type system PocketML has a set of builtin types: Vec (numpy arrays), Number, String, Bool, Tuples, Lists, Dict and Maybe. Num is an alias for Number and will replace it eventually. The operators *, /, +, - support addition of strings, numbers, and Vecs, as long as both sides of the operator have the same type. The ° operator acts the same as *, but allows two different types to be multiplied (i.e. vector-scalar multiplication, string multiplication, etc.). | Operator | Type | . | +,-,*,/ | a -> a -> a | . | ° | a -> b -> a | . | composition operators: | . | (y -> z) -> (x -> y) -> (x -> z) | . | >> | (x -> y) -> (y -> z) -> (x -> z) | . | $ | (x -> y) -> x -> y | . | logical operators / equality: | . | &&, || | Bool -> Bool -> Bool | . | =, | Number -> Number -> Bool | . #### 1.3 Builtins Most of the essentials are contained in the standard library `lib.std`, but some basic functions are passed through from python directly: | Function | Type | . | and,or | Bool -> Bool -> Bool | . | add,sub,mul,pow | Number -> Number -> Number | . | sqrt, inc, dec | Number -> Number | . | True, False | Bool | . | equal | a -> a -> Bool | . | lt | Number -> Number -> Bool | . | print | a -> () | . | print2 | a -> b -> () | . ",
    "url": "/Features.html",
    
    "relUrl": "/Features.html"
  },"64": {
    "doc": "Walkthrough: Coding Game of Life in PocketML",
    "title": "Walkthrough: Coding Game of Life in PocketML",
    "content": "## Walkthrough: Coding Game of Life in PocketML #### 1.1 Conways Game of Life I think most people in this space are familiar with Game of Life, but heres a quick overview: Conways Game of Life is a grid based simulation of cells. They can die, live or come to life. The rules are very simple but give rise to emergent organic-looking behaviour. Game of Life is actually Turing complete. The rules are as follows: - A cells stays alive and/or gets born when it has three alive neighbours - A cell dies when it has more or less than 3 neighbours. #### 1.2 Setup in PocketML First we'll need some libraries: ```python import lib.std; import lib.image; import lib.math; import lib.tea; ``` We will represent the playing grid as a small image. Let's start with a 60x60 grid. We can create an image by calling the `image` function with a vector that denotes the size (`@(width, height)`): ``` let w = 60; let i = image @(w,w); ``` > Note: I left out the types. PocketML can infer them. If you > were to click on the typing-button in the editor with the > cursor on our image `i`, you would get `i : Img`. #### 1.3 Checking neighbouring cells To determine if a cell should live or die, we need to know the number of living neighbours. To access the neighbours we will use offsets from the position of the cell we want to check: ```python let offsets = [ @(-1,-1),@(0,-1), @(1,-1), @(-1,0),@(1,0), # The middle row has only two cells, because # we do not want to count the cell itself. @(-1,1),@(0,1),@(1,1) ]; ``` To get all the neighbouring pixels/cells we will map over the offsets: ```python map (\\offset -> let p = imgGet buf (v + offset); # v + o is vector addition! # Out of bounds access to an image returns the empty vector. if vecLen p == 0 then 0 else vecAt 0 p) offsets ``` Now we can filter them to only get the live cells and then count them using `len`. Let's also wrap the entire thing in a function: ```sml let nAlive buf v = let offsets = [ @(-1,-1),@(0,-1),@(1,-1), @(-1,0),@(1,0), @(-1,1),@(0,1),@(1,1) ]; len (filter (\\x -> x > 0) $ map (\\o -> let p = imgGet buf (v+o); if vecLen p == 0 then 0 else vecAt 0 p) offsets); ``` #### 1.4 Updating the cells We can write the rules from above as a function: ```sml let determineAlive : Bool -> Number -> Bool; let determineAlive c n = if c then not (n 3) else (n == 3) ; ``` Now we can copy our image to a buffer for fast read access and map over every pixel using `imgMap` from lib.image. We'll color live pixels white and dead ones black. > Note: This mutates our image, which is a sin in > functional languages, but we'll go with it to > increase performance ```sml let tick img = let buf = imgBuf img; imgMap img (\\x y cell -> let n = nAlive buf @(x,y); let c = vecAt 0 cell > 0; if determineAlive c n then @(255,255,255,255) else @(0,0,0,255) ); ``` #### 1.5 Populating our playing grid We could have loaded our image from a file using `imgLoad`. Alternatively we can make a function to add cell patterns from a 2D list: > Note: imap \"map with index\". This is similar to/inspired by a for > loop with enumerate in python. > The builtin `map` functions are also fast because they use python for loops > internally. ```python let addPattern img v p=imap (\\y l-> imap # rows (\\x c-> setpixel img (v+@(x,y)) # columns (@(c,c,c,255) ° 255) ) l) p; ``` #### 1.6 Running the app / Event loop Because we want to actually see the game, we need to build a GUI. We need `update`, the initial state and `view` like in ELM. Let's count the ticks since the app started to slow down the games tick/update rate a little: > Note: Our state is `Number` in this case (the number of ticks)! > We'll increase (`inc`) it every frame. ```sml let update : Event -> Number -> Number; let update e t = case e | Tick -> do when (divisible t 5) (\\_ -> tick i) inc t ; ``` The playing field will be displayed using a textured rectangle (`TRect`). ```sml let view _ = TRect @(0,0) @(width,width) i; ``` Now we can start the app using `setTick`: ```sml setTick 0 update view ``` #### 1.7 Add patterns I have added a gosper glider gun: ```sml let _ = do addPattern i @(15, 20) gosper ; ``` `gosper` is a really big list, so you'll have to see the source code (gol.ml) for the details :). #### 1.8 End result / Gallery ![An image of the end result (Glider gun)](/gameoflife.png) ",
    "url": "/GameOfLife.html",
    
    "relUrl": "/GameOfLife.html"
  }
}
